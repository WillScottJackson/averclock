// TODO general scheduler addTask(pointer,interval,offset)
// and better with a queue and priorities?

// TODO feed-forward brightness adjusting based on LDR value. 2 values is fine.
// TODO debounced (async) button for setting time. Logarithmically repeating response, adjusting minutes and hours at the same time
// TODO alarm?
// TODO split into headers (and defines for SPI commands)
// TODO use registers instead of digitalwrite, etc
// TODO use registers instead of SPI library
// TODO support for bare multiplexed display without SPI

// this is automatically generated by deploy.sh
#include "current_time.h"
#include "../config.h"
#include "schavr.h"

//#include "main.h"

#include <SPI.h>

typedef struct {
	char hours;
	char minutes;
	char seconds;
} elapsed;

#ifdef AUTO_TIME
	// initialise with compile-time time with an offset to account for build/upload time
	elapsed time = {HOURS,MINUTES,SECONDS};
#else
	elapsed time = {0,0,0};
#endif

void init_display(void);

// tasks
void inc_time (void);
void update_display (char);
void update_brightness (void);

void setup () {
	SCH_init(50);
	// account for compile upload time
	inc_time();
	inc_time();
	inc_time();
	init_display();

	pinMode(LDR_PIN,INPUT);
	// 20K pullup
	digitalWrite(LDR_PIN,HIGH);

#ifndef DISPLAY_ADC
	SCH_add_task(inc_time,1,20);
	SCH_add_task(update_display,1,20);
#else
	SCH_add_task(display_adc,2,100);
#endif

#ifdef AUTO_BRIGHTNESS
	SCH_add_task(update_brightness,2,1);
#endif
	SCH_start();
}

void loop () {
	SCH_dispatch_tasks();
	SCH_sleep();
}

// call at 1Hz
void inc_time (void) {
	if (++time.seconds == 60) {
		time.minutes++;
		time.seconds = 0;
	}

	if (time.minutes == 60) {
		time.hours++;
		time.minutes = 0;
	}

	if (time.hours == 24)
		time.hours = 0;
}

void update_display () {
	static char colon_state = 1;

	colon_state = ! colon_state;

	digitalWrite(DISP_SS,0);

#ifdef TOGGLE_COLON
	// dots
	SPI.transfer(0x77);
	// colon or no colon
	SPI.transfer(colon_state?1<<4:0);
#endif

	// hours (1-2 digit)
	SPI.transfer(time.hours/10?:'x');
	SPI.transfer(time.hours%10);

	// minutes
	SPI.transfer(time.minutes/10);
	SPI.transfer(time.minutes%10);

	// deselect display
	digitalWrite(DISP_SS,1);
}

void init_display(void) {
	// init SPI

	// slave select pin init
	pinMode (DISP_SS, OUTPUT);
	digitalWrite(DISP_SS,1);

	// initialize SPI:
	SPI.begin();
	SPI.setClockDivider(SPI_CLOCK_DIV64);

	// wait for it to boot
	delay(300);

	// reset, turn on colon
	digitalWrite(DISP_SS,0);
	// reset
	SPI.transfer(0x76);
	// dots
	SPI.transfer(0x77);
	// colon
	SPI.transfer(0x10);
	// max brightness
	SPI.transfer(0x7A);
	SPI.transfer(DISP_BRIGHTEST);
	digitalWrite(DISP_SS,1);

	// fill with initial time (force)
	update_display();
}

void update_brightness() {
	unsigned int light = 0;

	// is display bright?
	static bool bright = 1;

	light = analogRead(LDR_PIN);


	if ((light < BRIGHTNESS_THRESH_LIGHT) && !bright) {
		digitalWrite(DISP_SS,0);
		// max brightness
		SPI.transfer(0x7A);
		SPI.transfer(DISP_BRIGHTEST);
		bright = 1;
		digitalWrite(DISP_SS,1);
	} else if ((light > BRIGHTNESS_THRESH_DARK) && bright) {
		digitalWrite(DISP_SS,0);
		// dim display
		SPI.transfer(0x7A);
		SPI.transfer(DISP_DIMMEST);
		bright = 0;
		// deselect display
		digitalWrite(DISP_SS,1);
	}

}

void display_adc() {
	unsigned int light = 0;

	light = analogRead(LDR_PIN);

	digitalWrite(DISP_SS,0);

	SPI.transfer(light/1000%10);
	SPI.transfer(light/100 %10);
	SPI.transfer(light/10  %10);
	SPI.transfer(light/1   %10);

	// deselect display
	digitalWrite(DISP_SS,1);
}
